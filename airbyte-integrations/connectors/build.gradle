plugins {
    id 'base'
    id 'ru.vyarus.use-python' version '2.3.0'
    id 'com.bmuschko.docker-remote-api' version '9.4.0'
}

// Configure Docker client
docker {
    registryCredentials {
        url = 'https://index.docker.io/v1/'
        username = System.getenv('DOCKER_HUB_USERNAME') ?: 'airbyte'
        password = System.getenv('DOCKER_HUB_PASSWORD') ?: ''
    }
}

// Import Docker plugin classes
import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerTagImage

// Pyenv support.
try {
    def pyenvRoot = "pyenv root".execute()
    if (pyenvRoot.waitFor() == 0) {
        ext.pyenvRoot = pyenvRoot.text.trim()
    }
} catch (IOException _) {
    // Swallow exception if pyenv is not installed.
}

def pythonBin = layout.buildDirectory.file('.venv/bin/python').get().asFile.absolutePath

// python is required by the connectors project to run airbyte-ci from source to build connector images.
python {
    envPath = layout.buildDirectory.file('.venv').get().asFile
    minPythonVersion = '3.11' // should be 3.11 for local development

    // Pyenv support.
    try {
        def pyenvRoot = "pyenv root".execute()
        def pyenvLatest = "pyenv latest ${minPythonVersion}".execute()
        // Pyenv definitely exists at this point: use 'python' instead of 'python3' in all cases.
        pythonBinary "python"
        if (pyenvRoot.waitFor() == 0 && pyenvLatest.waitFor() == 0) {
            pythonPath "${pyenvRoot.text.trim()}/versions/${pyenvLatest.text.trim()}/bin"
        }
    } catch (IOException _) {
        // Swallow exception if pyenv is not installed.
    }

    scope = 'VIRTUALENV'
    installVirtualenv = true
    // poetry is required for installing and running airbyte-ci
    pip 'poetry:1.5.1'
}

def poetryInstallAirbyteCI = tasks.register('poetryInstallAirbyteCI', Exec) {
    workingDir rootProject.file('airbyte-ci/connectors/pipelines')
    commandLine pythonBin
    args "-m", "poetry", "install", "--no-cache"
}
poetryInstallAirbyteCI.configure {
    dependsOn tasks.named('pipInstall')
}
def poetryCleanVirtualenv = tasks.register('cleanPoetryVirtualenv', Exec) {
    workingDir rootProject.file('airbyte-ci/connectors/pipelines')
    commandLine pythonBin
    args "-m", "poetry", "env", "remove", "--all"
    onlyIf {
        layout.buildDirectory.file('venv/bin/python').get().asFile.exists()
    }
}
tasks.named('clean').configure {
    dependsOn poetryCleanVirtualenv
}

allprojects {
    // Adds airbyte-ci task.
    def airbyteCIConnectorsTask = { String taskName, String... connectorsArgs ->
        def task = tasks.register(taskName, Exec) {
            workingDir rootDir
            environment "CI", "1" // set to use more suitable logging format
            commandLine pythonBin
            args "-m", "poetry"
            args "--directory", "${rootProject.file('airbyte-ci/connectors/pipelines').absolutePath}"
            args "run"
            args "airbyte-ci", "connectors", "--name=${project.name}"
            args connectorsArgs
            // Forbid these kinds of tasks from running concurrently.
            // We can induce serial execution by giving them all a common output directory.
            outputs.dir rootProject.file("${rootProject.buildDir}/airbyte-ci-lock")
            outputs.upToDateWhen { false }
        }
        task.configure { dependsOn poetryInstallAirbyteCI }
        return task
    }

    // Build connector image as part of 'assemble' task.
    // This is required for local 'integrationTest' execution.
    def buildConnectorImage = airbyteCIConnectorsTask(
            'buildConnectorImage', '--disable-report-auto-open', 'build', '--use-host-gradle-dist-tar')
    buildConnectorImage.configure {
        // Images for java projects always rely on the distribution tarball.
        dependsOn tasks.matching { it.name == 'distTar' }
        // Ensure that all files exist beforehand.
        dependsOn tasks.matching { it.name == 'generate' }
    }
    tasks.named('assemble').configure {
        // We may revisit the dependency on assemble but the dependency should always be on a base task.
        dependsOn buildConnectorImage
    }

    // Convenience tasks for local airbyte-ci execution.
    airbyteCIConnectorsTask('airbyteCIConnectorBuild', 'build')
    airbyteCIConnectorsTask('airbyteCIConnectorTest', 'test')
}

// Configure Docker image building tasks for all connector projects
subprojects { project ->
    // Only apply to connector projects
    if (project.path.startsWith(':airbyte-integrations:connectors:')) {
        // Determine connector type during configuration phase
        def isJavaConnector = project.file('build.gradle').exists()
        def isPythonConnector = project.file('setup.py').exists() || project.file('pyproject.toml').exists()
        def connectorType = isJavaConnector ? 'java' : (isPythonConnector ? 'python' : null)
        if (connectorType == null) {
            logger.warn("Could not determine connector type for ${project.name}. " +
                    "Expected either a Java or Python connector.")
            return // Skip this project
        }
        // Set project properties for use in tasks
        project.ext.connectorType = connectorType
        // Task to build connector Docker image using Docker plugin
        def buildConnectorDockerImage = project.tasks.register('buildConnectorDockerImage', DockerBuildImage) {
            description = 'Build connector Docker image using Docker plugin'
            group = 'build'
            // For Java connectors, depend on distTar task
            if (connectorType == 'java') {
                dependsOn project.tasks.matching { it.name == 'distTar' }
            }
            
            inputDir = project.projectDir
            dockerFile = new File(rootProject.file("docker-images"), "Dockerfile.${connectorType}-connector")
            
            // Get native architecture
            def nativeArch = "arm64"
            try {
                def archProcess = "uname -m".execute()
                archProcess.waitFor()
                def arch = archProcess.text.trim()
                if (arch == "amd64" || arch == "x86_64") {
                    nativeArch = "amd64"
                }
            } catch (Exception e) {
                logger.warn("Failed to detect native architecture: ${e.message}. Defaulting to arm64.")
            }
            logger.lifecycle("Detected native architecture: ${nativeArch}")
            
            // Determine base image based on connector type
            def baseImage = connectorType == 'java' ? 'airbyte/java-connector-base:2.0.1' : 'airbyte/python-connector-base:1.1.0'
            
            // Configure Docker build options
            platform = "linux/${nativeArch}"
            labels = [
                'io.airbyte.version': '3.11.15',
                'io.airbyte.name': "airbyte/${project.name}"
            ]
            buildArgs = [
                'BASE_IMAGE': baseImage,
                'CONNECTOR_NAME': project.name
            ]
            images = ["airbyte/${project.name}:dev"]
            
            doFirst {
                logger.lifecycle("Building Docker image for ${project.name} (${connectorType} connector)")
            }
        }
        // Main task to build connector Docker image
        project.tasks.register('buildImage') {
            description = 'Build connector Docker image'
            group = 'build'
            dependsOn buildConnectorDockerImage
            // Always re-run this task
            outputs.upToDateWhen { false }
            doFirst {
                logger.lifecycle("Building Docker image for connector: ${project.name}")
            }
            doLast {
                logger.lifecycle("Successfully built Docker image:")
                logger.lifecycle("- airbyte/${project.name}:dev")
                logger.lifecycle("Test by running: docker run --rm -it airbyte/${project.name}:dev spec")
            }
        }
    }
}
