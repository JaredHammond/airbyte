plugins {
    id 'application'
    id 'airbyte-bulk-connector'
    id "io.airbyte.gradle.docker"
}

airbyteBulkConnector {
    core = 'load'
    toolkits = ['load-s3', 'load-avro', 'load-aws']
    cdk = 'local'
}

application {
    mainClass = 'io.airbyte.integrations.destination.s3_v2.S3V2Destination'

    applicationDefaultJvmArgs = [
            '-XX:+ExitOnOutOfMemoryError', '-XX:MaxRAMPercentage=75.0',
//            Uncomment to run locally:
//          '--add-opens', 'java.base/java.lang=ALL-UNNAMED'
//            Uncomment to enable remote profiling:
//            '-XX:NativeMemoryTracking=detail',
//            '-Djava.rmi.server.hostname=localhost',
//            '-Dcom.sun.management.jmxremote=true',
//            '-Dcom.sun.management.jmxremote.port=6000',
//            '-Dcom.sun.management.jmxremote.rmi.port=6000',
//            '-Dcom.sun.management.jmxremote.local.only=false',
//            '-Dcom.sun.management.jmxremote.authenticate=false',
//            '-Dcom.sun.management.jmxremote.ssl=false'
    ]
}

// Uncomment to run locally
//run {
//    standardInput = System.in
//}

// Exclude conflicting log4j-over-slf4j dependency
configurations.all {
        exclude group: "org.slf4j", module: "slf4j-reload4j"
}

airbyte {
    docker {
        imageName.set("destination-s3")
    }
}

import io.airbyte.gradle.GenerateConnectorBuildArgs

def generateConnectorDockerBuildArgs = tasks.register('generateConnectorDockerBuildArgs', GenerateConnectorBuildArgs) {
    metadata.set(layout.projectDirectory.file('metadata.yaml'))
    output.set(layout.buildDirectory.file('docker/buildArgs.properties'))
}

/* Lazily read the generated buildArgs.properties file in the build/docker directory, and turns each PROP=VALUE line into a docker build arg. */
tasks.named('dockerBuildx').configure { task ->
    dependsOn generateConnectorDockerBuildArgs
    inputs.file generateConnectorDockerBuildArgs.flatMap { it.output }

    def propsText = providers.fileContents(generateConnectorDockerBuildArgs.flatMap { it.output } as Provider<RegularFile>)
            .asText
            .orElse('')                                 // handle missing file

    def propsMap = propsText.map { txt ->
        txt.readLines()
                .findAll { it.contains('=') }
                .collectEntries { line ->
                    def (k, v) = line.split('=', 2)
                    [(k.trim()): v.trim()]
                }
    }

    /*  Inject the map *during configuration* while buildArgs are still mutable, but its contents are resolved
        only when Gradle needs buildArgs (after the task graph is ready).      */
    task.buildArgs.putAll(propsMap)

    task.dependsOn 'dockerCopyDockerfile'
    task.dockerfile.set(layout.buildDirectory.file('airbyte/docker/Dockerfile'))
}

/* Copy the top-level dockerfile into the build directory. */
tasks.named('dockerCopyDockerfile', Copy).configure {
    description = 'Copy shared Dockerfile into build/airbyte/docker'
    from (rootProject.file('docker-images/Dockerfile.java-connector-non-airbyte-ci')) {
        rename { 'Dockerfile' }
    }
    into layout.buildDirectory.dir('airbyte/docker')
}
